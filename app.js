/******************************************************************
 Fake News Challenge ‚Äî auto-load stimuli from filenames like:
 "1-f-ll-3-vl-2.png"
  story 1, fake, low-linguistic, ling variant 3, low-visual, vis variant 2

 Requires:
  - stimuli_manifest.json generated by make_manifest.py
  - stimuli images reachable via the paths in the manifest
 Run with a local server (recommended):
  python -m http.server 8000
******************************************************************/

const LS_KEY = "fn_challenge_runs_v1";
const MANIFEST_URL = "stimuli_manifest.json";

// ---------- Parsing ----------
function parseStimulusPath(path) {
  const filename = path.split("/").pop();
  const re = /^(\d+)-(t|f)-(lh|ll)-(\d+)-(vh|vl)-(\d+)\.(png|jpg|jpeg|webp)$/i;
  const m = filename.match(re);
  if (!m) return null;

  const story = Number(m[1]);
  const truthToken = m[2].toLowerCase();     // t/f
  const lingToken = m[3].toLowerCase();      // lh/ll
  const lingVar = Number(m[4]);
  const visToken = m[5].toLowerCase();       // vh/vl
  const visVar = Number(m[6]);

  return {
    id: filename.replace(/\.[^.]+$/, ""),
    img: path,
    story,
    truth: truthToken === "t" ? "true" : "fake",
    lingQuality: lingToken === "lh" ? "high" : "low",
    lingVariant: lingVar,
    visQuality: visToken === "vh" ? "high" : "low",
    visVariant: visVar,
  };
}

// ---------- Local storage ----------
function loadRuns(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch { return []; }
}
function saveRun(runSummary){
  const runs = loadRuns();
  runs.push(runSummary);
  localStorage.setItem(LS_KEY, JSON.stringify(runs.slice(-500)));
}
function clearRuns(){
  localStorage.removeItem(LS_KEY);
}

// ---------- Helpers ----------
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
function mean(nums){ return nums.length ? nums.reduce((a,b)=>a+b,0)/nums.length : 0; }
function formatSeconds(s){
  if(!isFinite(s)) return "‚Äî";
  if(s < 60) return `${s.toFixed(1)}s`;
  const m = Math.floor(s/60);
  const r = s - m*60;
  return `${m}m ${r.toFixed(0)}s`;
}
function percentileRank(value, values){
  if(values.length === 0) return null;
  const below = values.filter(v => v < value).length;
  const equal = values.filter(v => v === value).length;
  const rank = (below + 0.5*equal) / values.length;
  return Math.round(rank * 100);
}
function countBy(arr, pred){
  return arr.reduce((acc, x)=> acc + (pred(x)?1:0), 0);
}

// ---------- Deck selection (NO REPEATED STORY) ----------
function pickBalancedDeckNoRepeatStory(allStimuli, n=6){
  // group by story
  const byStory = new Map();
  for(const s of allStimuli){
    if(!byStory.has(s.story)) byStory.set(s.story, []);
    byStory.get(s.story).push(s);
  }
  const storyIds = Array.from(byStory.keys()).sort((a,b)=>a-b);

  if(storyIds.length < n){
    throw new Error(`Need at least ${n} distinct stories, but only found ${storyIds.length}.`);
  }

  // shuffle story order so repeats across runs look different
  const storyPool = shuffle(storyIds).slice(0, n);

  // For balancing: we prefer certain cells early
  const preferredCellOrder = [
    "true|high|high","fake|high|high",
    "true|high|low","fake|high|low",
    "true|low|high","fake|low|high",
    "true|low|low","fake|low|low",
  ];

  // Track which cells we've filled (soft goal)
  const cellCount = new Map(preferredCellOrder.map(k => [k, 0]));

  function keyOf(s){ return `${s.truth}|${s.lingQuality}|${s.visQuality}`; }

  // Pick one stimulus per story with best balancing score
  const picked = [];

  for(const story of storyPool){
    const candidates = shuffle(byStory.get(story));

    // score candidate by how much it helps fill underrepresented cells
    let best = null;
    let bestScore = -Infinity;

    for(const c of candidates){
      const k = keyOf(c);
      const current = cellCount.has(k) ? cellCount.get(k) : 999;

      // Lower counts are better (we want to fill empty/rare cells)
      // Add small randomness so choices vary between runs
      const score = (10 - current) + Math.random()*0.25;

      if(score > bestScore){
        bestScore = score;
        best = c;
      }
    }

    if(!best){
      throw new Error(`No candidates found for story ${story}.`);
    }

    picked.push(best);

    const k = keyOf(best);
    if(!cellCount.has(k)) cellCount.set(k, 0);
    cellCount.set(k, cellCount.get(k) + 1);
  }

  // Final shuffle for play order
  return shuffle(picked);
}

// ---------- Influence classification ----------
function computeInfluence(results){
  // 1 if user answered TRUE, else 0
  const toTrue = r => (r.choice === "true" ? 1 : 0);

  const lingHigh = results.filter(r => r.stim.lingQuality === "high").map(toTrue);
  const lingLow  = results.filter(r => r.stim.lingQuality === "low").map(toTrue);

  const visHigh  = results.filter(r => r.stim.visQuality === "high").map(toTrue);
  const visLow   = results.filter(r => r.stim.visQuality === "low").map(toTrue);

  const pTrueLingHigh = mean(lingHigh); // P(answer TRUE | ling high)
  const pTrueLingLow  = mean(lingLow);  // P(answer TRUE | ling low)
  const pTrueVisHigh  = mean(visHigh);  // P(answer TRUE | vis high)
  const pTrueVisLow   = mean(visLow);   // P(answer TRUE | vis low)

  const lingEffect = pTrueLingHigh - pTrueLingLow;
  const visEffect  = pTrueVisHigh - pTrueVisLow;

  // Optional heuristic tag: very fast + almost no cue sensitivity
  const avgRt = mean(results.map(r=>r.rtSec));
  const cueSensitivity = Math.max(Math.abs(lingEffect), Math.abs(visEffect));

  if(avgRt < 8 && cueSensitivity < 0.10){
    return {
      label: "‚ö° HEURISTIC-DRIVEN",
      explanation: "Your TRUE/FAKE choices barely changed with presentation cues, and you decided very quickly.",
      metrics: { pTrueLingHigh, pTrueLingLow, pTrueVisHigh, pTrueVisLow, lingEffect, visEffect }
    };
  }

  // Balanced if the magnitudes are close
  if(Math.abs(Math.abs(lingEffect) - Math.abs(visEffect)) < 0.05){
    return {
      label: "‚öñÔ∏è BALANCED JUDGE",
      explanation: "Your tendency to answer TRUE changed similarly with language and visual presentation.",
      metrics: { pTrueLingHigh, pTrueLingLow, pTrueVisHigh, pTrueVisLow, lingEffect, visEffect }
    };
  }

  // Dominant cue = larger absolute effect
  if(Math.abs(lingEffect) > Math.abs(visEffect)){
    return {
      label: "üìù LANGUAGE-DRIVEN JUDGE",
      explanation: "Your TRUE/FAKE choices shifted more with writing quality than with visual design.",
      metrics: { pTrueLingHigh, pTrueLingLow, pTrueVisHigh, pTrueVisLow, lingEffect, visEffect }
    };
  }

  return {
    label: "üé® VISUAL-DRIVEN JUDGE",
    explanation: "Your TRUE/FAKE choices shifted more with visual design than with writing quality.",
    metrics: { pTrueLingHigh, pTrueLingLow, pTrueVisHigh, pTrueVisLow, lingEffect, visEffect }
  };
}


// ---------- App state ----------
const app = document.getElementById("app");

const State = {
  screen: "loading", // loading | intro | play | result1 | result2 | result3 | result4
  ALL_STIMULI: [],
  deck: [],
  idx: 0,
  startTs: 0,
  results: [],
};

function setHTML(html){ app.innerHTML = html; }

// ---------- Screens ----------
function render(){
  if(State.screen === "loading") return renderLoading();
  if(State.screen === "intro") return renderIntro();
  if(State.screen === "play") return renderPlay();
  if(State.screen === "result1") return renderResult1();
  if(State.screen === "result2") return renderResult2();
  if(State.screen === "result3") return renderResult3();
  if(State.screen === "result4") return renderResult4();
}

function renderLoading(){
  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">Loading stimuli‚Ä¶</div>
          <div class="sub">Reading stimuli_manifest.json</div>
        </div>
      </div>
      <div class="content">
        <div class="small">If this stays here, ensure you are serving the folder via a local web server.</div>
      </div>
    </div>
  `);
}

function renderIntro(){
  const runs = loadRuns();
  const storySet = new Set(State.ALL_STIMULI.map(s => s.story));
  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">Fake News Challenge</div>
          <div class="sub">6 articles. Decide: <b>TRUE</b> or <b>FAKE</b>.</div>
        </div>
        <div class="pill">Stimuli: <b>${State.ALL_STIMULI.length}</b> ‚Ä¢ Stories: <b>${storySet.size}</b></div>
      </div>
      <div class="content">
        <div class="row">
          <div class="col">
            <div class="big">Can you spot it?</div>
            <div class="kpi">
              <span>üß© 6 rounds</span>
              <span>‚è±Ô∏è We track time</span>
              <span>üß† You‚Äôll get a ‚Äúdecision style‚Äù</span>
              <span>üìö No story repeats</span>
            </div>
            <div class="hr"></div>
            <div class="small">Device plays (for comparisons): <b>${runs.length}</b></div>
          </div>
          <div class="col">
            <div class="box">
              <h3>Privacy</h3>
              <div class="small">
                No personal data. Comparisons are stored only on this device.
              </div>
            </div>
            <div class="btnbar">
              <button onclick="resetDeviceStats()">Reset device stats</button>
              <button class="primary" onclick="startGame()">Start ‚ñ∂</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  `);
}

function resetDeviceStats(){
  clearRuns();
  render();
}

function startGame(){
  State.deck = pickBalancedDeckNoRepeatStory(State.ALL_STIMULI, 6);
  State.idx = 0;
  State.results = [];
  State.startTs = performance.now();
  State.screen = "play";
  render();
}

function renderPlay(){
  const total = State.deck.length;
  const stim = State.deck[State.idx];
  const pct = Math.round((State.idx / total) * 100);

  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">Round ${State.idx + 1} / ${total}</div>
          <div class="sub">Decide: is this article true or fake?</div>
        </div>
        <div class="pill">Progress: ${pct}%</div>
      </div>

      <div class="content">
        <div class="stimWrap">
          <div class="stimTop">
            <div class="pill">Story: <b>${stim.story}</b></div>
            <div class="pill">Time is measured automatically</div>
          </div>

          <div class="imgFrame">
            <img src="${stim.img}" alt="stimulus screenshot"
                 onerror="this.onerror=null; this.alt='Image not found'; this.src='';" />
          </div>

          <div class="btnbar">
            <button class="bad" onclick="answer('fake')">FAKE</button>
            <button class="good" onclick="answer('true')">TRUE</button>
          </div>

          <div class="progress"><div style="width:${pct}%;"></div></div>
          <div class="note">File: <b>${stim.id}</b></div>
        </div>
      </div>
    </div>
  `);
}

function answer(choice){
  const stim = State.deck[State.idx];
  const now = performance.now();
  const rtSec = (now - State.startTs) / 1000;
  const correct = (choice === stim.truth);

  State.results.push({ stim, choice, correct, rtSec });

  State.idx += 1;
  State.startTs = performance.now();

  if(State.idx >= State.deck.length){
    finalizeRun();
    State.screen = "result1";
  }
  render();
}

function finalizeRun(){
  const correctCount = State.results.filter(r=>r.correct).length;
  const accuracy = correctCount / State.results.length;
  const avgRt = mean(State.results.map(r=>r.rtSec));
  const influence = computeInfluence(State.results);

  saveRun({
    ts: new Date().toISOString(),
    correctCount,
    total: State.results.length,
    accuracy,
    avgRt,
    influenceLabel: influence.label
  });
}

// ---------- Result screens ----------
function renderResult1(){
  const runs = loadRuns();
  const last = runs[runs.length - 1];

  const correctCount = State.results.filter(r=>r.correct).length;
  const total = State.results.length;
  const accuracyPct = Math.round((correctCount/total)*100);

  const avgPlayerCorrect = runs.length > 0 ? mean(runs.map(r=>r.correctCount)) : null;
  const percentile = runs.length > 1
    ? percentileRank(last.correctCount, runs.slice(0,-1).map(r=>r.correctCount))
    : null;

  const barWidth = clamp(accuracyPct, 0, 100);

  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">üéØ YOUR RESULT</div>
          <div class="sub">Overall performance</div>
        </div>
        <div class="pill">Players on this device: <b>${runs.length}</b></div>
      </div>

      <div class="content">
        <div class="row">
          <div class="col">
            <div class="big">${correctCount} / ${total}</div>
            <div class="kpi">
              <span>Accuracy: <b>${accuracyPct}%</b></span>
              <span>Avg decision time: <b>${formatSeconds(last.avgRt)}</b></span>
            </div>

            <div class="progress"><div style="width:${barWidth}%;"></div></div>

            <div class="hr"></div>

            <div class="small">
              Average player today: <b>${avgPlayerCorrect ? avgPlayerCorrect.toFixed(1) : "‚Äî"} / ${total}</b><br/>
              ${percentile === null
                ? `You‚Äôre the first player on this device ‚Äî play again to build comparisons!`
                : `You did better than <b>${percentile}%</b> of players on this device.`}
            </div>

            <div class="btnbar">
              <button onclick="State.screen='intro'; render();">Finish</button>
              <button class="primary" onclick="State.screen='result2'; render();">Next ‚ñ∂</button>
            </div>
          </div>

          <div class="col">
            <div class="box">
              <h3>What this measures</h3>
              <div class="small">
                Score = correct true/fake decisions.<br/>
                Time = how long you took per article.<br/>
                Next: you‚Äôll see how you compare on a speed‚Äìaccuracy map.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `);
}

function renderResult2(){
  const runs = loadRuns();
  const last = runs[runs.length - 1];

  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">‚è±Ô∏è SPEED vs ACCURACY</div>
          <div class="sub">Your dot vs other players on this device</div>
        </div>
        <div class="pill">You: <b>${Math.round(last.accuracy*100)}%</b> ‚Ä¢ <b>${formatSeconds(last.avgRt)}</b></div>
      </div>

      <div class="content">
        <div class="grid2">
          <div class="box">
            <h3>Map</h3>
            <canvas id="scatter"></canvas>
            <div class="note"> Accuracy increases upwards. Faster decisions are on the left; slower ones on the right.</div>
          </div>
          <div class="box">
            <h3>Your category</h3>
            <div class="val" id="perfCat">‚Äî</div>
            <div class="small" id="perfText">‚Äî</div>
            <div class="hr"></div>
            <div class="small">
              People often do better when they take a little more time ‚Äî but speed can be fine if you‚Äôre consistent.
            </div>
          </div>
        </div>

        <div class="btnbar">
          <button onclick="State.screen='result1'; render();">‚óÄ Back</button>
          <button class="primary" onclick="State.screen='result3'; render();">Next ‚ñ∂</button>
        </div>
      </div>
    </div>
  `);

  //drawScatter(runs, runs.length - 1);
  requestAnimationFrame(() => drawScatter(runs, runs.length - 1));
  const cat = performanceCategory(last);
  document.getElementById("perfCat").textContent = cat.title;
  document.getElementById("perfText").textContent = cat.text;
}

function performanceCategory(run){
  const acc = run.accuracy;
  const t = run.avgRt;

  if(acc >= 0.75 && t <= 12) return { title:"TOP PERFORMER", text:"High accuracy with fast decisions." };
  if(acc >= 0.75)           return { title:"CAREFUL & ACCURATE", text:"High accuracy‚Äîtaking time seems to help you." };
  if(acc < 0.55 && t <= 8)  return { title:"FAST GUESSER", text:"Very quick decisions, but accuracy suffered." };
  if(acc < 0.55)            return { title:"STRUGGLING (TAKE A BEAT)", text:"Try slowing down a little and checking plausibility." };
  if(t <= 10)               return { title:"FAST & OK", text:"Good pace‚Äîaccuracy is decent." };
  return { title:"CAREFUL & OK", text:"You took time, with moderate accuracy." };
}

function drawScatter(runs, highlightIndex){
  const canvas = document.getElementById("scatter");
  const ctx = canvas.getContext("2d");

  // ---- robust sizing ----
  const parent = canvas.parentElement; // the .box that contains it
  const rect = parent.getBoundingClientRect();

  // pick reasonable fallback sizes
  const cssW = Math.max(300, Math.floor(rect.width - 2));  // minus borders
  const cssH = 260;

  // set CSS size explicitly (important!)
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";

  // set pixel buffer size for HiDPI
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);

  // draw in CSS pixel coordinates
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const w = cssW, h = cssH;
  const padL = 60, padR = 18, padT = 18, padB = 50;

  // ---- DEBUG: prove we are drawing ----
  ctx.clearRect(0,0,w,h);
  //ctx.strokeStyle = "rgba(255,255,255,0.25)";
  //ctx.lineWidth = 1;
  //ctx.strokeRect(0.5, 0.5, w-1, h-1);

  //ctx.fillStyle = "rgba(255,255,255,0.6)";
  //ctx.font = "12px system-ui";
  //ctx.fillText(`runs=${runs.length}  w=${w} h=${h} dpr=${dpr.toFixed(2)}`, 10, 16);

  // If no runs, still show axes
  const times = runs.map(r=>r.avgRt);
  const tMin = 0;
  const tMax = Math.max(10, ...times, 25);  // ensure non-zero range

  const aMin = 0;     // 0%
  const aMax = 1.0;   // 100%

  const x = (t) => padL + ((t - tMin) / (tMax - tMin)) * (w - padL - padR);      // left fast -> right slow
  const y = (a) => padT + (1 - ((a - aMin) / (aMax - aMin))) * (h - padT - padB);

  // ---- grid ----
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 1;

  const yTicks = [0, 0.25, 0.5, 0.75, 1.0];
  for(const at of yTicks){
    const yy = y(at);
    ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(w-padR, yy); ctx.stroke();
  }

  const xTickCount = 5;
  for(let i=0;i<=xTickCount;i++){
    const tt = tMin + i*(tMax - tMin)/xTickCount;
    const xx = x(tt);
    ctx.beginPath(); ctx.moveTo(xx, padT); ctx.lineTo(xx, h-padB); ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // ---- labels ----
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  ctx.font = "12px system-ui";
  ctx.fillText("Accuracy (%)", 8, 32);
  ctx.fillText("Time (seconds)", w/2 - 40, h - 12);

  // y tick labels
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  for(const at of yTicks){
    const yy = y(at);
    ctx.fillText(`${Math.round(at*100)}%`, 10, yy + 4);
  }

  // x tick labels
  for(let i=0;i<=xTickCount;i++){
    const tt = tMin + i*(tMax - tMin)/xTickCount;
    const xx = x(tt);
    ctx.fillText(`${Math.round(tt)}s`, xx - 10, h - 28);
  }

  // ---- points ----
  runs.forEach((r, i)=>{
    // small jitter in pixels so identical points don't overlap perfectly
    const jitter = (i === highlightIndex) ? 0 : 6;
    const jx = (Math.random() - 0.5) * jitter;
    const jy = (Math.random() - 0.5) * jitter;
  
    const px = x(r.avgRt) + jx;
    const py = y(r.accuracy) + jy;
  
    if(i === highlightIndex){
      ctx.fillStyle = "rgba(106,166,255,0.95)";
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(px, py, 7, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillText("YOU", px + 10, py - 10);
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
    }
  });
}


function renderResult3(){
  const influence = computeInfluence(State.results);
  const m = influence.metrics;

  const lingHighTotal = countBy(State.results, r=>r.stim.lingQuality==="high");
  const lingLowTotal  = countBy(State.results, r=>r.stim.lingQuality==="low");
  const visHighTotal  = countBy(State.results, r=>r.stim.visQuality==="high");
  const visLowTotal   = countBy(State.results, r=>r.stim.visQuality==="low");

  const trueLingHigh = Math.round(m.pTrueLingHigh * lingHighTotal);
  const trueLingLow  = Math.round(m.pTrueLingLow  * lingLowTotal);
  const trueVisHigh  = Math.round(m.pTrueVisHigh  * visHighTotal);
  const trueVisLow   = Math.round(m.pTrueVisLow   * visLowTotal);

  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">üß† WHAT INFLUENCED YOUR JUDGEMENTS?</div>
          <div class="sub">Language vs visual presentation</div>
        </div>
        <div class="pill">Decision style</div>
      </div>

      <div class="content">
        <div class="grid2">
          <div class="box">
            <h3>Patterns in your answers</h3>
            <div class="small">
              When <b>LANGUAGE</b> looked professional:<br/>
              You answered <b>TRUE</b> <b>${trueLingHigh} / ${lingHighTotal}</b> times
              (${Math.round(m.pTrueLingHigh * 100)}%)
              
              <div class="hr"></div>

              When <b>LANGUAGE</b> looked weak:<br/>
              You answered <b>TRUE</b> <b>${trueLingLow} / ${lingLowTotal}</b> times
              (${Math.round(m.pTrueLingLow * 100)}%)

              <div class="hr"></div>

              When <b>VISUAL DESIGN</b> looked professional:<br/>
              You answered <b>TRUE</b> <b>${trueVisHigh} / ${visHighTotal}</b> times
              (${Math.round(m.pTrueVisHigh * 100)}%)

              <div class="hr"></div>

              When <b>VISUAL DESIGN</b> looked weak:<br/>
              You answered <b>TRUE</b> <b>${trueVisLow} / ${visLowTotal}</b> times
              (${Math.round(m.pTrueVisLow * 100)}%)
            </div>
          </div>

          <div class="box">
            <h3>You are a</h3>
            <div class="val">${influence.label}</div>
            <div class="small">${influence.explanation}</div>
            <div class="hr"></div>
            <div class="note">
              (This is inferred from how often you judged articles as <b>TRUE</b> under different presentation conditions.)
            </div>
          </div>
        </div>

        <div class="btnbar">
          <button onclick="State.screen='result2'; render();">‚óÄ Back</button>
          <button class="primary" onclick="State.screen='result4'; render();">Next ‚ñ∂</button>
        </div>
      </div>
    </div>
  `);
}


function renderResult4(){
  setHTML(`
    <div class="card">
      <div class="header">
        <div>
          <div class="title">üîç WHAT RESEARCH SHOWS</div>
          <div class="sub">Why this game exists</div>
        </div>
        <div class="pill">Open Day Demo</div>
      </div>

      <div class="content">
        <div class="box">
          <div class="small">
            ‚Ä¢ Most people are only slightly better than chance at spotting fake news.<br/><br/>
            ‚Ä¢ Professional language can make fake news seem more credible.<br/><br/>
            ‚Ä¢ Visual design matters less than many people expect ‚Äî but it can still mislead.
          </div>
          <div class="hr"></div>
          <div class="small">
            Want to try again and see how your dot moves?
          </div>
        </div>

        <div class="btnbar">
          <button onclick="State.screen='intro'; render();">Finish</button>
          <button class="primary" onclick="startGame()">Play again</button>
        </div>
      </div>
    </div>
  `);
}

// ---------- Boot: load manifest ----------
async function boot(){
  render();
  const res = await fetch(MANIFEST_URL, { cache: "no-store" });
  if(!res.ok) throw new Error(`Could not load ${MANIFEST_URL} (HTTP ${res.status})`);
  const paths = await res.json();

  const parsed = paths.map(parseStimulusPath).filter(Boolean);

  if(parsed.length === 0){
    throw new Error("No stimuli matched the expected filename pattern.");
  }

  State.ALL_STIMULI = parsed;
  State.screen = "intro";
  render();
}

boot().catch(err=>{
  console.error(err);
  setHTML(`
    <div class="card">
      <div class="header"><div class="title">Error loading stimuli</div></div>
      <div class="content">
        <div class="small">
          ${String(err.message || err)}<br/><br/>
          Common fix: run a local server (not file://). Example:<br/>
          <code>python -m http.server 8000</code>
        </div>
      </div>
    </div>
  `);
});
